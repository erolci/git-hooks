#!/bin/sh
# shellcheck disable=SC1111
set -ue

# Redirect output to stderr.
exec 1>&2

GLOBAL_CONFIG_NAMESPACE="hooks"

NULL_REF=0000000000000000000000000000000000000000

random_line ()
{
    if sort --help | grep -q -- --random-sort
    then
        sort --random-sort | head -n1
    else
        # As a fallback use first line
        head -n1
    fi
}

safe_tput ()
{
    tput "$@" 2>/dev/null || :
}

time_ms ()
{
    # Sadly, macOS date(3) does not support %N
    perl -MTime::HiRes=time -e 'printf "%d\n", time * 1000'
}

if [ -t 1 ] && [ "$( safe_tput colors )" -gt 8 ]
then
    TPUT_PRIMARY="$( safe_tput sgr0 )"
    TPUT_SECONDARY="$( safe_tput dim )"
    TPUT_ERROR="$( safe_tput setaf 1 )"
    TPUT_WARNING="$( safe_tput setaf 3 )"
    TPUT_VERY_HIGH_VALUE="$TPUT_ERROR"
    TPUT_HIGH_VALUE="$TPUT_WARNING"
else
    TPUT_PRIMARY=""
    TPUT_SECONDARY=""
    TPUT_ERROR=""
    TPUT_WARNING=""
    TPUT_VERY_HIGH_VALUE=
    TPUT_HIGH_VALUE=
fi

MS_HIGH=1500
MS_VERY_HIGH=3000

# TODO Set VERBOSITY from --verbose | -v | -vv | -vvv etc.
# TODO Add a hook that checks if --fixup=… matches anything

VERBOSITY="$( git config --get "hooks.verbosity" || echo 0)"
if [ "$VERBOSITY" -ge 9 ]
then
    set -x
fi
export VERBOSITY

HOOK_TYPE="$( basename "$0" .sh )"
export HOOK_TYPE

if [ "$HOOK_TYPE" = "commit-msg" ]
then
    COMMIT_MESSAGE="${1-}"
else
    COMMIT_MESSAGE=""
fi
export COMMIT_MESSAGE

PACKAGE_DIR="$( dirname "$( readlink "$0" || echo "$0" )" )/.."
export PACKAGE_DIR

BASE_BRANCH="$( git config --get-regexp '^branch\..*\.remote' | head -n1 | cut -d. -f2 )"
export BASE_BRANCH

if git rev-parse --verify HEAD >/dev/null 2>&1
then
    AGAINST=HEAD
else
    # Initial commit: diff against an empty tree object
    AGAINST="$( git hash-object -t tree /dev/null )"
fi
export AGAINST

XARGS_MAX_ARGS=512
if command xargs --help 2>&1 | grep -q -- --no-run-if-empty
then
    # shellcheck disable=SC2139
    alias xargs="command xargs -n $XARGS_MAX_ARGS --no-run-if-empty"
else
    # On MacOS xargs does not have that option (which is a GNU
    # extension), but acts that way by default
    # shellcheck disable=SC2139
    alias xargs="command xargs -n $XARGS_MAX_ARGS"
fi

# Commonly used to disable interactive mode
CI=true
export CI

TMPDIR="${TMPDIR:-/tmp}"
export TMPDIR

PATH="${PATH}:./node_modules/.bin"
export PATH


# Figure out how git was called
git_cmd_regex="(\/[a-zA-Z0-9_/-]+\/)?git"
if [ -e "/proc/$PPID/cmdline" ]
then
    # On systems with procfs get command from there since it contains
    # words separated by null bytes, so we can restore quoting
    PARENT_ARGV0="\"$( cut -d '' -f1 "/proc/$PPID/cmdline" )\""
    if echo "$PARENT_ARGV0" | grep -Eq "^\"${git_cmd_regex}\"$"
    then
        PARENT_ARGV="\"$( cut -d '' -f2- "/proc/$PPID/cmdline" | sed -e 's/\x0*$//' -e 's/\x0/" "/g' )\""
    else
        PARENT_ARGV0=
        PARENT_ARGV=
    fi
else
    # On systems without procfs get command from ps, which has quotes
    # stripped and hope for the best.
    parent_cmd="$( ps -p "$PPID" -o command= )"
    if printf "%s" "$parent_cmd" | grep -qE "^${git_cmd_regex}[[:space:]]+"
    then
        PARENT_ARGV0="$( printf "%s" "$parent_cmd" | sed -E -e "s/^($git_cmd_regex).*/\\1/" )"
        PARENT_ARGV="$( printf "%s" "$parent_cmd" | sed -E "s/^${git_cmd_regex}[[:space:]]+//" )"
    else
        PARENT_ARGV0=
        PARENT_ARGV=
    fi
    unset parent_cmd
fi
unset git_cmd_regex


success_messages="All hooks seem happy.
You are all good.
Nice job.
Keep it up.
Everything is good with the world."


cprintf ()
{
    colour="$1"
    prefix="$2"
    fmt="$3"
    shift 3
    # shellcheck disable=SC2059
    printf "${colour}${prefix}${fmt}${TPUT_PRIMARY}\n" "$@"
}

error ()
{
    cprintf "$TPUT_ERROR" "ERROR: " "$@" 1>&2
}

warning ()
{
    cprintf "$TPUT_WARNING" "WARNING: " "$@"
}

secondary ()
{
    cprintf "$TPUT_SECONDARY" "" "$@"
}

is_enabled ()
{
    config_name="$1"
    test "$( git config --get "$config_name" || echo true )" != "false"
}

run_hooks ()
{
    if ! is_enabled "$GLOBAL_CONFIG_NAMESPACE.enabled"
    then
        return
    fi

    dir="$PACKAGE_DIR/$HOOK_TYPE.d"
    pattern="^$( git config --get "$GLOBAL_CONFIG_NAMESPACE.pattern" || echo '.*')$"
    # TODO Support global hooks in ~/.config/githooks (overwritable in git config)
    # TODO Support local hooks in ./.githooks (overwritable in git config)
    find "$dir" -maxdepth 1 -type f | sort |
        while read -r hook
        do
            if [ -x "$hook" ]
            then
                name="$( basename "$hook" .sh  | sed 's/^[0-9_ -]*//' )"
                CONFIG_NAMESPACE="$GLOBAL_CONFIG_NAMESPACE.$name"
                enabled_shorthand_config_name="$CONFIG_NAMESPACE"
                if
                  echo "$name" | grep -q "$pattern"
                then
                    if [ "$VERBOSITY" -ge 1 ]
                    then
                        secondary "$name"
                    fi

                    if
                      ! is_enabled "$CONFIG_NAMESPACE.enabled" ||
                      ! is_enabled "$enabled_shorthand_config_name"
                    then
                        if [ "$VERBOSITY" -ge 2 ]
                        then
                            secondary "→ disabled"
                        fi
                    else

                        start_ms=$( time_ms )

                        export GLOBAL_CONFIG_NAMESPACE CONFIG_NAMESPACE
                        export NULL_REF
                        # shellcheck disable=SC1090
                        if ! ( . "$hook" )
                        then
                            error "%s “%s” hook failed" "$HOOK_TYPE" "$name"
                            if [ -z "$PARENT_ARGV0" ]
                            then
                                secondary "To temporary disable add this directly after \`git\`:\n    -c %s=false " "$enabled_shorthand_config_name"
                            else
                                secondary "To temporary disable run:\n    %s -c %s=false %s" "$PARENT_ARGV0" "$enabled_shorthand_config_name" "$PARENT_ARGV"
                            fi
                            false
                        fi

                        end_ms=$( time_ms )
                        if [ "$VERBOSITY" -ge 2 ]
                        then
                            duration_ms=$(( end_ms - start_ms ))
                            if [ $duration_ms != 0 ]
                            then
                                if [ "$duration_ms" -gt "$MS_VERY_HIGH" ]
                                then
                                    duration_color="$TPUT_VERY_HIGH_VALUE"
                                elif [ "$duration_ms" -gt "$MS_HIGH" ]
                                then
                                    duration_color="$TPUT_HIGH_VALUE"
                                else
                                    duration_color=
                                fi
                                printf "${TPUT_SECONDARY}→ took ${duration_color}%.3fs${TPUT_PRIMARY}${TPUT_SECONDARY}.${TPUT_PRIMARY}\n" "${duration_ms}e-3"
                            fi
                        fi

                    fi
                fi
            fi
        done

    if [ "$VERBOSITY" -ge 0 ]
    then
        printf '✅ '
        echo "$success_messages" | random_line
    fi
}
